const { SlashCommandBuilder, PermissionFlagsBits, EmbedBuilder, AttachmentBuilder } = require('discord.js');
const { createCanvas, loadImage } = require('canvas');
const path = require('path');
const fs = require('fs');

// Fonction pour g√©n√©rer une image de bienvenue avec l‚Äôavatar du membre
async function generateWelcomeImage(member, roleName) {
    console.log(`[G√©n√©ration Image] D√©but pour ${member.user.tag} (ID: ${member.id}) - R√¥le: ${roleName}`);

    // Chemin de l‚Äôimage de fond bas√© sur le nom du r√¥le
    let backgroundPath = path.join(__dirname, `../img/${roleName}.png`);
    if (!fs.existsSync(backgroundPath)) {
        console.warn(`[G√©n√©ration Image] Image introuvable pour ${roleName} : ${backgroundPath}. Utilisation de l‚Äôimage par d√©faut.`);
        backgroundPath = path.join(__dirname, '../img/default.png'); // Image par d√©faut locale
    }

    try {
        const background = await loadImage(backgroundPath);
        const avatarURL = member.user.displayAvatarURL({ format: 'png', size: 1024 }).replace('webp', 'png');
        const avatar = await loadImage(avatarURL);

        // Cr√©ation d‚Äôun canvas 1024x1024
        const canvas = createCanvas(1024, 1024);
        const ctx = canvas.getContext('2d');

        // Dessiner l‚Äôimage de fond
        ctx.drawImage(background, 0, 0, canvas.width, canvas.height);

        // Si le r√¥le est 'roleadd', dessiner l‚Äôavatar en cercle
        if (roleName === 'roleadd') {
            const avatarSize = 282;
            const x = (canvas.width - avatarSize) / 1.96;
            const y = (canvas.height - avatarSize) / 3.37;

            ctx.save();
            ctx.beginPath();
            ctx.arc(x + avatarSize / 2, y + avatarSize / 2, avatarSize / 2, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.clip();
            ctx.drawImage(avatar, x, y, avatarSize, avatarSize);
            ctx.restore();
        }

        const attachment = new AttachmentBuilder(canvas.toBuffer(), { name: 'welcome-image.png' });
        console.log('[G√©n√©ration Image] Image g√©n√©r√©e avec succ√®s.');
        return attachment;
    } catch (error) {
        console.error('[G√©n√©ration Image] Erreur lors de la g√©n√©ration :', error.stack);
        return null;
    }
}

module.exports = {
    // D√©finition de la commande Slash
    data: new SlashCommandBuilder()
        .setName('admit')
        .setDescription('Donner un r√¥le √† un membre et envoyer un message de bienvenue')
        .addUserOption(option =>
            option.setName('membre')
                .setDescription('Le membre √† qui attribuer un r√¥le')
                .setRequired(true))
        .addStringOption(option =>
            option.setName('role')
                .setDescription('Le r√¥le √† attribuer')
                .setRequired(true)
                .addChoices(
                    { name: 'Tampon', value: 'roleadd' },
                    { name: 'Certifi√©', value: 'roleadd2' },
                    { name: 'DM', value: 'roleadd3' },
                    { name: 'Galerie', value: 'roleadd4' },
                    { name: 'Torture', value: 'roleadd5' }
                )),

    // Fonction principale d‚Äôex√©cution
    async execute(interaction) {
        console.log(`[Commande /admit] Ex√©cut√©e par ${interaction.user.tag} (ID: ${interaction.user.id})`);

        // V√©rification des permissions : admin ou r√¥le modo
        const isAdmin = interaction.member.permissions.has(PermissionFlagsBits.Administrator);
        const hasModoRole = interaction.member.roles.cache.has(process.env.MODO);
        if (!isAdmin && !hasModoRole) {
            console.log(`[Permission refus√©e] ${interaction.user.tag} n‚Äôa pas les droits n√©cessaires`);
            return interaction.reply({
                content: 'Permission refus√©e : r√©serv√©e aux administrateurs ou mod√©rateurs.',
                ephemeral: true
            });
        }

        // Diff√©rer la r√©ponse pour √©viter un timeout (visible par tous)
        await interaction.deferReply();

        const targetMember = interaction.options.getMember('membre');
        const selectedRole = interaction.options.getString('role');

        // V√©rifier si le membre existe
        if (!targetMember) {
            console.log('[Erreur] Membre introuvable');
            return interaction.editReply({ content: 'Membre introuvable.' });
        }

        console.log(`[Commande /admit] Cible : ${targetMember.user.tag} (ID: ${targetMember.id}), R√¥le : ${selectedRole}`);

        // Configuration des r√¥les, canaux et messages personnalis√©s avec les nouveaux noms
        const rolesMap = {
            'roleadd': process.env.TAMPON_ROLE_ID,
            'roleadd2': process.env.CERTIFIE_ROLE_ID,
            'roleadd3': process.env.DM_ROLE_ID,
            'roleadd4': process.env.GALERIE_ROLE_ID,
            'roleadd5': process.env.TORTURE_ROLE_ID,
        };

        const channelMap = {
            'roleadd': process.env.ENTREEE_SORTIE_CHANNEL_ID,
            'roleadd2': process.env.SALLE_ELEVATION_CHANNEL_ID,
            'roleadd3': process.env.SALLE_ELEVATION_CHANNEL_ID,
            'roleadd4': process.env.SALLE_ELEVATION_CHANNEL_ID,
            'roleadd5': process.env.SALLE_ELEVATION_CHANNEL_ID,
        };

        const welcomeMessageMap = {
            'roleadd': `**Bienvenue** <@${targetMember.id}> !`,
            'roleadd2': `**F√©licitations pour ton r√¥le de Certifi√©**, <@${targetMember.id}> !`,
            'roleadd3': `**Bienvenue au r√¥le DM**, <@${targetMember.id}> !`,
            'roleadd4': `**Tu as atteint le r√¥le Galerie**, <@${targetMember.id}> !`,
            'roleadd5': `**Tu as atteint le r√¥le Torture**, <@${targetMember.id}> !`,
        };

        const roleToAddId = rolesMap[selectedRole];
        const roleToRemoveId = process.env.REGLEMENT_ACCEPTED_ROLE_ID; // Retir√© uniquement pour 'roleadd'
        const channelId = channelMap[selectedRole];

        try {
            // R√©cup√©rer les objets r√¥le et canal
            const roleToAdd = interaction.guild.roles.cache.get(roleToAddId);
            const roleToRemove = roleToRemoveId ? interaction.guild.roles.cache.get(roleToRemoveId) : null;
            const channel = interaction.guild.channels.cache.get(channelId);

            // V√©rifier si tout est valide
            if (!roleToAdd || !channel) {
                console.error(`[Erreur] R√¥le (${roleToAddId}) ou canal (${channelId}) introuvable`);
                return interaction.editReply({ content: 'R√¥le ou canal introuvable.' });
            }

            // Gestion des r√¥les
            if (selectedRole === 'roleadd' && roleToRemove) {
                await targetMember.roles.add(roleToAdd);
                await targetMember.roles.remove(roleToRemove);
                console.log(`[R√¥les] ${roleToAdd.name} ajout√©, ${roleToRemove.name} retir√© pour ${targetMember.user.tag}`);
            } else {
                await targetMember.roles.add(roleToAdd);
                console.log(`[R√¥les] ${roleToAdd.name} ajout√© √† ${targetMember.user.tag}`);
            }

            // G√©n√©rer et envoyer le message de bienvenue avec image
            const welcomeMessage = welcomeMessageMap[selectedRole];
            const attachment = await generateWelcomeImage(targetMember, selectedRole);

            if (attachment) {
                await channel.send({ content: welcomeMessage, files: [attachment] });
                console.log(`[Message] Bienvenue envoy√© dans ${channel.name} avec image pour ${targetMember.user.tag}`);
            } else {
                await channel.send({ content: welcomeMessage });
                console.log(`[Message] Bienvenue envoy√© dans ${channel.name} sans image pour ${targetMember.user.tag}`);
            }

            // Pr√©parer la r√©ponse avec un embed
            const replyEmbed = new EmbedBuilder()
                .setColor('#00FFAA')
                .setTimestamp()
                .setFooter({ text: `Ex√©cut√© par ${interaction.user.tag}` });

            // Message personnalis√© selon le r√¥le
            switch (selectedRole) {
                case 'roleadd':
                    replyEmbed.setDescription(`Bienvenue ${targetMember} ! Tu peux d√©sormais prendre tes <#1159894126607740968>. N'oublie pas le r√¥le membre !`);
                    break;
                case 'roleadd2':
                    replyEmbed.setDescription(`${targetMember} **est d√©sormais certifi√©.e !**`);
                    break;
                case 'roleadd3':
                    replyEmbed.setDescription(`${targetMember} **a d√©sormais acc√®s √† <#1284932254987976836> !**`);
                    break;
                case 'roleadd4':
                    replyEmbed.setDescription(`${targetMember} **a d√©sormais acc√®s √† <#1160842845960273961> !**`);
                    break;
                case 'roleadd5':
                    replyEmbed.setDescription(`${targetMember} **est arriv√©.e aux portes des ‚õìüóùüîó Salles de tortures. Faites chauffer vos outils pour l'accueillir !**`);
                    break;
            }

            // Envoyer la r√©ponse
            await interaction.editReply({ embeds: [replyEmbed] });
            console.log(`[Commande /admit] R√©ponse envoy√©e pour ${targetMember.user.tag}`);
        } catch (error) {
            console.error(`[Erreur] Dans /admit pour ${targetMember.user.tag} :`, error.stack);
            await interaction.editReply({ content: 'Erreur lors de l‚Äôex√©cution de la commande.' });
        }
    }
};